{"prompt": "Define a function fib(n:int)->int computing the nth Fibonacci number (n>=0). Then print fib(10).", "tests": ["assert fib(0)==0; assert fib(1)==1; assert fib(10)==55"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define factorial(n:int)->int using iteration (no recursion). Print factorial(8).", "tests": ["assert factorial(0)==1; assert factorial(5)==120; assert factorial(8)==40320"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define gcd(a:int,b:int)->int and lcm(a:int,b:int)->int. Use Euclid for gcd. Print lcm(21,6).", "tests": ["assert gcd(54,24)==6; assert lcm(21,6)==42; assert lcm(5,7)==35"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_prime(n:int)->bool (n>=0). Reasonably efficient for n<=10^6. Print is_prime(101).", "tests": ["assert is_prime(2) and is_prime(3) and is_prime(101); assert not is_prime(0) and not is_prime(1) and not is_prime(100)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define sieve(n:int)->list[int] returning all primes <= n. Print len(sieve(1000)).", "tests": ["p=sieve(30); assert p==[2,3,5,7,11,13,17,19,23,29]; assert len(sieve(2))==1; assert len(sieve(100))==25"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define nth_prime(k:int)->int (1-indexed). Print nth_prime(25).", "tests": ["assert nth_prime(1)==2; assert nth_prime(6)==13; assert nth_prime(25)==97"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define mod_pow(a:int,b:int,m:int)->int computing a^b mod m by fast exponentiation. Print mod_pow(5,117,19).", "tests": ["assert mod_pow(2,10,1000)==24; assert mod_pow(5,117,19)==1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define int_to_roman(num:int)->str (1..3999). Print int_to_roman(944).", "tests": ["assert int_to_roman(3)=='III'; assert int_to_roman(58)=='LVIII'; assert int_to_roman(944)=='CMXLIV'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define roman_to_int(s:str)->int (valid Roman). Print roman_to_int('MCMXCIV').", "tests": ["assert roman_to_int('III')==3; assert roman_to_int('LVIII')==58; assert roman_to_int('MCMXCIV')==1994"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_palindrome_num(x:int)->bool without converting to string (use math). Print is_palindrome_num(12321).", "tests": ["assert is_palindrome_num(0); assert is_palindrome_num(12321); assert not is_palindrome_num(123)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_armstrong(n:int)->bool (base 10). Print is_armstrong(371).", "tests": ["assert is_armstrong(0); assert is_armstrong(1); assert is_armstrong(153); assert is_armstrong(371); assert not is_armstrong(100)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define reverse_str(s:str)->str without slicing. Print reverse_str('stressed').", "tests": ["assert reverse_str('stressed')=='desserts'; assert reverse_str('ab')=='ba'; assert reverse_str('')==''"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_anagram(a:str,b:str)->bool (ignore case and spaces). Print is_anagram('Listen','Silent').", "tests": ["assert is_anagram('Listen','Silent'); assert is_anagram('A gentleman','Elegant man'); assert not is_anagram('abc','ab')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_isogram(s:str)->bool (letters only, ignore case/hyphens/spaces). Print is_isogram('background').", "tests": ["assert is_isogram('background'); assert not is_isogram('letter'); assert is_isogram('six-year-old')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define count_vowels(s:str)->int counting a,e,i,o,u (both cases). Print count_vowels('Apples and Oranges').", "tests": ["assert count_vowels('')==0; assert count_vowels('Apples and Oranges')==7"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define rle_encode(s:str)->str (run-length encoding, e.g., 'AAAB'->'3A1B'). Print rle_encode('WWWWBWW').", "tests": ["assert rle_encode('AAAB')=='3A1B'; assert rle_encode('WWWWBWW')=='4W1B2W'; assert rle_encode('')==''"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define caesar_cipher(s:str,shift:int)->str shifting letters (a-z, A-Z) with wrap; preserve non-letters. Print caesar_cipher('Abc-Z!',3).", "tests": ["assert caesar_cipher('Abc-Z!',3)=='Def-C!'; assert caesar_cipher('xyz',4)=='bcd'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define most_common_char(s:str)->str returning the most frequent non-space char; ties -> smallest lexicographically. Print most_common_char('abbcccdddde').", "tests": ["assert most_common_char('abbcccdddde')=='d'; assert most_common_char('aabb')=='a'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define two_sum(nums:list[int],target:int)->tuple[int,int] returning indices i<j with nums[i]+nums[j]==target. Print two_sum([2,7,11,15],9).", "tests": ["assert two_sum([2,7,11,15],9) in [(0,1)]; assert set(two_sum([3,2,4],6))=={1,2}"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define unique(seq:list)->list preserving first occurrence order. Print unique([1,2,2,3,1,4]).", "tests": ["assert unique([1,2,2,3,1,4])==[1,2,3,4]; assert unique([])==[]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define rotate_right(a:list[int],k:int)->list[int] rotating right by k (k may exceed len). Print rotate_right([1,2,3,4,5],2).", "tests": ["assert rotate_right([1,2,3,4,5],2)==[4,5,1,2,3]; assert rotate_right([1],10)==[1]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define flatten(nested:list)->list that flattens a list of lists by one level only. Print flatten([[1,2],[3],[4,5]]).", "tests": ["assert flatten([[1,2],[3],[4,5]])==[1,2,3,4,5]; assert flatten([])==[]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define group_anagrams(words:list[str])->list[list[str]]. Order within groups doesn't matter; groups order doesn't matter. Print groups for ['eat','tea','tan','ate','nat','bat'].", "tests": ["res=group_anagrams(['eat','tea','tan','ate','nat','bat']); assert sorted([sorted(g) for g in res])==sorted([['ate','eat','tea'],['nat','tan'],['bat']])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define top_k_frequent(nums:list[int],k:int)->list[int]. If tie, smaller number first. Print top_k_frequent([1,1,1,2,2,3],2).", "tests": ["assert top_k_frequent([1,1,1,2,2,3],2)==[1,2]; assert top_k_frequent([4,4,4,5,5,6],2)==[4,5]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define merge_intervals(iv:list[list[int]])->list[list[int]] merging overlaps; output sorted by start. Print merge_intervals([[1,3],[2,6],[8,10],[15,18]]).", "tests": ["assert merge_intervals([[1,3],[2,6],[8,10],[15,18]])==[[1,6],[8,10],[15,18]]; assert merge_intervals([[1,4],[4,5]])==[[1,5]]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define binary_search(a:list[int],x:int)->int returning index or -1 if absent (a is sorted asc). Print binary_search([1,3,5,7,9],7).", "tests": ["assert binary_search([1,3,5,7,9],7)==3; assert binary_search([1,3,5],2)==-1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define merge_sort(a:list[int])->list[int] (no built-in sort). Print merge_sort([3,1,4,1,5,9]).", "tests": ["assert merge_sort([3,1,4,1,5,9])==[1,1,3,4,5,9]; assert merge_sort([])==[]; assert merge_sort([1])==[1]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define coin_change(coins:list[int],amount:int)->int returning min coins to make amount or -1 if impossible. Print coin_change([1,2,5],11).", "tests": ["assert coin_change([1,2,5],11)==3; assert coin_change([2],3)==-1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define lis_length(nums:list[int])->int returning length of the Longest Increasing Subsequence. Print lis_length([10,9,2,5,3,7,101,18]).", "tests": ["assert lis_length([10,9,2,5,3,7,101,18])==4; assert lis_length([0,1,0,3,2,3])==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define edit_distance(a:str,b:str)->int (Levenshtein, insert/delete/replace cost 1). Print edit_distance('intention','execution').", "tests": ["assert edit_distance('kitten','sitting')==3; assert edit_distance('intention','execution')==5"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define knapsack_01(W:int,wt:list[int],val:list[int])->int maximizing value with capacity W. Print knapsack_01(7,[6,3,4,2],[30,14,16,9]).", "tests": ["assert knapsack_01(7,[6,3,4,2],[30,14,16,9])==46; assert knapsack_01(10,[3,3,3],[10,20,30])==60"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define transpose(mat:list[list[int]])->list[list[int]]. Print transpose([[1,2,3],[4,5,6]]).", "tests": ["assert transpose([[1,2,3],[4,5,6]])==[[1,4],[2,5],[3,6]]; assert transpose([[1]])==[[1]]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define rotate_matrix(mat:list[list[int]])->list[list[int]] rotating square matrix 90Â° clockwise in-place or return new. Print rotate_matrix([[1,2],[3,4]]).", "tests": ["assert rotate_matrix([[1,2],[3,4]])==[[3,1],[4,2]]; assert rotate_matrix([[1]])==[[1]]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define spiral_order(mat:list[list[int]])->list[int] returning elements in spiral order. Print spiral_order([[1,2,3],[4,5,6],[7,8,9]]).", "tests": ["assert spiral_order([[1,2,3],[4,5,6],[7,8,9]])==[1,2,3,6,9,8,7,4,5]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define dijkstra(n:int,edges:list[tuple[int,int,int]],src:int)->list[int] returning min distances (INF=10**15) on non-negative weighted graph. Print dijkstra(5,[(0,1,2),(0,2,5),(1,2,1),(1,3,2),(2,3,3),(3,4,1)],0).", "tests": ["INF=10**15; dist=dijkstra(5,[(0,1,2),(0,2,5),(1,2,1),(1,3,2),(2,3,3),(3,4,1)],0); assert dist[0]==0 and dist[1]==2 and dist[2]==3 and dist[3]==4 and dist[4]==5"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define eval_rpn(tokens:list[str])->int evaluating Reverse Polish Notation with +,-,*,/. Integer division truncates toward zero. Print eval_rpn(['2','1','+','3','*']).", "tests": ["assert eval_rpn(['2','1','+','3','*'])==9; assert eval_rpn(['4','13','5','/','+'])==6; assert eval_rpn(['10','6','9','3','+','-11','*','/','*','17','+','5','+'])==22"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define parse_csv_line(line:str)->list[str] handling commas and double-quotes per RFC basics (quote escape by doubling). Print parse_csv_line('\"a,b\",c,\"d\"\"e\"').", "tests": ["assert parse_csv_line('\"a,b\",c,\"d\"\"e\"')==['a,b','c','d\"e']; assert parse_csv_line('a,,b')==['a','','b']"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_valid_parentheses(s:str)->bool for (),{},[]. Print is_valid_parentheses('([{}])').", "tests": ["assert is_valid_parentheses('()') and is_valid_parentheses('([{}])'); assert not is_valid_parentheses('(]')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define generate_parentheses(n:int)->list[str] generating all valid combinations of n pairs of '()'. Print len(generate_parentheses(3)).", "tests": ["g=generate_parentheses(3); assert set(g)==set(['((()))','(()())','(())()','()(())','()()()'])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define permutations(lst:list[int])->list[list[int]] returning all permutations (order of permutations not important). Print len(permutations([1,2,3])).", "tests": ["res=permutations([1,2,3]); assert len(res)==6 and sorted([tuple(x) for x in res])==sorted([(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Implement class LRUCache(capacity:int) with methods get(key:int)->int and put(key:int,value:int)->None. get returns -1 if missing. Use O(1) operations. Print nothing, just define the class.", "tests": ["c=LRUCache(2); c.put(1,1); c.put(2,2); assert c.get(1)==1; c.put(3,3); assert c.get(2)==-1; c.put(4,4); assert c.get(1)==-1; assert c.get(3)==3 and c.get(4)==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define stack_with_queues supporting push(x), pop()->int, top()->int, empty()->bool using two queues (collections.deque allowed). Print nothing.", "tests": ["from collections import deque; s=stack_with_queues(); s.push(1); s.push(2); assert s.top()==2; assert s.pop()==2; assert not s.empty(); assert s.pop()==1; assert s.empty()"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define queue_with_stacks supporting push(x), pop()->int, peek()->int, empty()->bool using two stacks (lists). Print nothing.", "tests": ["q=queue_with_stacks(); q.push(1); q.push(2); assert q.peek()==1; assert q.pop()==1; assert not q.empty(); assert q.pop()==2; assert q.empty()"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define sum_digits(n:int)->int returning the sum of decimal digits of n (treat n as absolute). Then print sum_digits(12345).", "tests": ["assert sum_digits(0)==0", "assert sum_digits(12345)==15", "assert sum_digits(-99)==18"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define digital_root(n:int)->int that repeatedly sums digits until one digit remains. Print digital_root(9875).", "tests": ["assert digital_root(0)==0", "assert digital_root(9)==9", "assert digital_root(10)==1", "assert digital_root(9875)==2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define pow_iter(a:int,b:int)->int computing ab using iteration only (b>=0). Print pow_iter(2,10).", "tests": ["assert pow_iter(2,10)==1024", "assert pow_iter(5,0)==1", "assert pow_iter(3,1)==3"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_power_of_two(n:int)->bool. Return True iff n is a power of two (>0). Print is_power_of_two(1024).", "tests": ["assert is_power_of_two(1)", "assert is_power_of_two(1024)", "assert not is_power_of_two(0) and not is_power_of_two(3)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define popcount(n:int)->int returning the number of set bits in nonnegative n. Print popcount(0b1011010).", "tests": ["assert popcount(0)==0", "assert popcount(1)==1", "assert popcount(0b1011010)==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define hamming_distance(a:int,b:int)->int (number of differing bits). Print hamming_distance(29,15).", "tests": ["assert hamming_distance(0,0)==0", "assert hamming_distance(1,4)==2", "assert hamming_distance(29,15)==2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define reverse_int(x:int)->int that reverses decimal digits preserving sign (no 32-bit overflow rules). Print reverse_int(-120).", "tests": ["assert reverse_int(123)==321", "assert reverse_int(-120)==-21", "assert reverse_int(0)==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define to_base(n:int,b:int)->str for 0<=n and 2<=b<=36 using digits 0-9A-Z. Print to_base(255,16).", "tests": ["assert to_base(0,2)=='0'", "assert to_base(10,2)=='1010'", "assert to_base(255,16)=='FF'", "assert to_base(31,36)=='V'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define from_base(s:str,b:int)->int parsing base 2..36 (case-insensitive). Print from_base('FF',16).", "tests": ["assert from_base('FF',16)==255", "assert from_base('1010',2)==10", "assert from_base('v',36)==31"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define gcd_list(nums:list)->int computing gcd of all numbers (list non-empty). Print gcd_list([8,12,16]).", "tests": ["assert gcd_list([8,12,16])==4", "assert gcd_list([7])==7"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define lcm_list(nums:list)->int computing lcm of all numbers (list non-empty). Print lcm_list([5,7,3]).", "tests": ["assert lcm_list([4,6])==12", "assert lcm_list([5,7,3])==105"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define binomial(n:int,k:int)->int computing C(n,k) for 0<=k<=n using an efficient multiplicative method. Print binomial(30,15).", "tests": ["assert binomial(5,2)==10", "assert binomial(30,15)==155117520"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define trailing_zeros_factorial(n:int)->int returning the number of trailing zeros in n!. Print trailing_zeros_factorial(100).", "tests": ["assert trailing_zeros_factorial(5)==1", "assert trailing_zeros_factorial(10)==2", "assert trailing_zeros_factorial(100)==24"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_perfect_square(n:int)->bool (n>=0) without using sqrt from math. Print is_perfect_square(16).", "tests": ["assert is_perfect_square(0) and is_perfect_square(1) and is_perfect_square(16)", "assert not is_perfect_square(14)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define integer_sqrt(n:int)->int returning floor(sqrt(n)) for n>=0. Print integer_sqrt(10).", "tests": ["assert integer_sqrt(10)==3", "assert integer_sqrt(16)==4", "assert integer_sqrt(0)==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define collatz_steps(n:int)->int returning steps to reach 1 by Collatz rules (n>=1). Print collatz_steps(3).", "tests": ["assert collatz_steps(1)==0", "assert collatz_steps(3)==7", "assert collatz_steps(6)==8"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_happy(n:int)->bool (happy number in base 10). Print is_happy(19).", "tests": ["assert is_happy(19)", "assert not is_happy(2)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define prime_factors(n:int)->list[int] returning the multiset of prime factors sorted ascending (1->[]). Print prime_factors(84).", "tests": ["assert prime_factors(1)==[]", "assert prime_factors(84)==[2,2,3,7]", "assert prime_factors(97)==[97]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define count_divisors(n:int)->int counting positive divisors. Print count_divisors(28).", "tests": ["assert count_divisors(1)==1", "assert count_divisors(6)==4", "assert count_divisors(28)==6"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define phi(n:int)->int (Euler's totient). Print phi(36).", "tests": ["assert phi(1)==1", "assert phi(9)==6", "assert phi(36)==12"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define mod_inverse(a:int,m:int)->int|None returning modular inverse of a mod m or None if it doesn't exist. Print mod_inverse(3,11).", "tests": ["assert mod_inverse(3,11)==4", "assert mod_inverse(2,4) is None"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define crt2(a1:int,m1:int,a2:int,m2:int)->int|None returning the smallest x>=0 satisfying xâ¡a1 (mod m1) and xâ¡a2 (mod m2), or None if inconsistent. Print crt2(2,3,3,5).", "tests": ["assert crt2(2,3,3,5)==8", "assert crt2(1,2,0,4) is None", "assert crt2(2,4,6,8)==6"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define sum_of_proper_divisors(n:int)->int (excluding n). Print sum_of_proper_divisors(28).", "tests": ["assert sum_of_proper_divisors(1)==0", "assert sum_of_proper_divisors(12)==16", "assert sum_of_proper_divisors(28)==28"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_perfect_number(n:int)->bool (n>=1). Print is_perfect_number(28).", "tests": ["assert is_perfect_number(28)", "assert not is_perfect_number(12)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define amicable_pair(a:int,b:int)->bool. Print amicable_pair(220,284).", "tests": ["assert amicable_pair(220,284)", "assert not amicable_pair(10,20)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define remove_vowels(s:str)->str removing a,e,i,o,u (both cases). Print remove_vowels('Beautiful day').", "tests": ["assert remove_vowels('hello')=='hll'", "assert remove_vowels('AEIOUaeiou')==''"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define compress_spaces(s:str)->str collapsing multiple spaces to one while preserving a single leading/trailing space if present. Print compress_spaces(' a b ').", "tests": ["assert compress_spaces('a b c')=='a b c'", "assert compress_spaces(' spaced out ')==' spaced out '"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define camel_to_snake(s:str)->str converting CamelCase or mixed camelCase to snake_case. Print camel_to_snake('HTTPRequest').", "tests": ["assert camel_to_snake('camelCase')=='camel_case'", "assert camel_to_snake('HTTPRequest')=='http_request'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define snake_to_camel(s:str)->str converting snake_case to lowerCamelCase. Print snake_to_camel('hello_world').", "tests": ["assert snake_to_camel('hello_world')=='helloWorld'", "assert snake_to_camel('make_it_work')=='makeItWork'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define reverse_words(s:str)->str reversing word order, trimming extra spaces. Print reverse_words(' the sky is blue ').", "tests": ["assert reverse_words('the sky is blue')=='blue is sky the'", "assert reverse_words(' hello world ')=='world hello'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define longest_common_prefix(strs:list)->str. Print longest_common_prefix(['flower','flow','flight']).", "tests": ["assert longest_common_prefix(['flower','flow','flight'])=='fl'", "assert longest_common_prefix(['dog','racecar','car'])==''"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define lcs_length(a:str,b:str)->int returning Longest Common Subsequence length. Print lcs_length('abcde','ace').", "tests": ["assert lcs_length('abcde','ace')==3", "assert lcs_length('abc','abc')==3", "assert lcs_length('abc','def')==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define lcsubstr_length(a:str,b:str)->int returning Longest Common Substring length. Print lcsubstr_length('abcdef','zcdemf').", "tests": ["assert lcsubstr_length('abcdef','zcdemf')==3", "assert lcsubstr_length('abcd','efgh')==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_palindrome_str(s:str)->bool ignoring non-alphanumerics and case. Print is_palindrome_str('A man, a plan, a canal: Panama').", "tests": ["assert is_palindrome_str('A man, a plan, a canal: Panama')", "assert not is_palindrome_str('race a car')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define count_substrings(s:str, sub:str)->int counting (possibly overlapping) occurrences. Print count_substrings('aaaa','aa').", "tests": ["assert count_substrings('aaaa','aa')==3", "assert count_substrings('abc','a')==1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define first_unique_char(s:str)->int returning index of first non-repeating char or -1. Print first_unique_char('leetcode').", "tests": ["assert first_unique_char('leetcode')==0", "assert first_unique_char('loveleetcode')==2", "assert first_unique_char('aabb')==-1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define prefix_function(s:str)->list[int] (KMP prefix table with pi[0]=0). Print prefix_function('ababa').", "tests": ["assert prefix_function('ababa')==[0,0,1,2,3]", "assert prefix_function('aaaa')==[0,1,2,3]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define find_all_occurrences(text:str,pattern:str)->list[int] using KMP (allow overlaps). Print find_all_occurrences('ababa','aba').", "tests": ["assert find_all_occurrences('ababa','aba')==[0,2]", "assert find_all_occurrences('aaaaa','aa')==[0,1,2,3]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define min_window_substring(s:str,t:str)->str returning the minimum window of s containing all chars of t (with multiplicity). Print min_window_substring('ADOBECODEBANC','ABC').", "tests": ["assert min_window_substring('ADOBECODEBANC','ABC')=='BANC'", "assert min_window_substring('a','a')=='a'", "assert min_window_substring('a','aa')==''"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define valid_palindrome_k(s:str,k:int)->bool that returns True if s can become a palindrome by deleting at most k chars. Print valid_palindrome_k('abca',1).", "tests": ["assert valid_palindrome_k('abca',1)", "assert not valid_palindrome_k('abc',1)", "assert valid_palindrome_k('deeee',1)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define decode_string(s:str)->str decoding patterns like '3[a2[c]]'. Print decode_string('2[abc]3[cd]ef').", "tests": ["assert decode_string('3[a2[c]]')=='accaccacc'", "assert decode_string('2[abc]3[cd]ef')=='abcabccdcdcdef'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define zigzag_convert(s:str,num_rows:int)->str (like the classic ZigZag conversion). Print zigzag_convert('PAYPALISHIRING',3).", "tests": ["assert zigzag_convert('PAYPALISHIRING',3)=='PAHNAPLSIIGYIR'", "assert zigzag_convert('PAYPALISHIRING',4)=='PINALSIGYAHRPI'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define longest_palindrome_substring(s:str)->str returning any longest palindromic substring. Print len(longest_palindrome_substring('babad')).", "tests": ["res=longest_palindrome_substring('babad'); assert res in ('bab','aba')", "assert longest_palindrome_substring('cbbd')=='bb'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define frequency_sort(s:str)->str sorting characters by descending frequency; ties by ascending char. Print frequency_sort('tree').", "tests": ["assert frequency_sort('tree')=='eert'", "assert frequency_sort('cccaaa')=='aaaccc'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define remove_adjacent_duplicates(s:str)->str repeatedly removing adjacent equal pairs until no more. Print remove_adjacent_duplicates('abbaca').", "tests": ["assert remove_adjacent_duplicates('abbaca')=='ca'", "assert remove_adjacent_duplicates('azxxzy')=='ay'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define move_zeroes(nums:list)->list[int] moving zeros to end preserving order. Print move_zeroes([0,1,0,3,12]).", "tests": ["assert move_zeroes([0,1,0,3,12])==[1,3,12,0,0]", "assert move_zeroes([0,0])==[0,0]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define product_except_self(nums:list)->list[int] without division. Print product_except_self([1,2,3,4]).", "tests": ["assert product_except_self([1,2,3,4])==[24,12,8,6]", "assert product_except_self([0,0])==[0,0]", "assert product_except_self([0,1,2])==[2,0,0]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define max_subarray(nums:list)->int (Kadane's algorithm). Print max_subarray([-2,1,-3,4,-1,2,1,-5,4]).", "tests": ["assert max_subarray([-2,1,-3,4,-1,2,1,-5,4])==6", "assert max_subarray([1])==1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define max_circular_subarray(nums:list)->int (maximum sum in circular array). Print max_circular_subarray([5,-3,5]).", "tests": ["assert max_circular_subarray([1,-2,3,-2])==3", "assert max_circular_subarray([5,-3,5])==10", "assert max_circular_subarray([-3,-2,-3])==-2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define majority_element(nums:list)->int for element > n/2. Print majority_element([2,2,1,1,1,2,2]).", "tests": ["assert majority_element([3,2,3])==3", "assert majority_element([2,2,1,1,1,2,2])==2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define majority_elements_n3(nums:list)->list[int] returning all elements appearing > n/3 times (order not important). Print majority_elements_n3([1,1,1,3,3,2,2,2]).", "tests": ["assert set(majority_elements_n3([3,2,3]))=={3}", "assert set(majority_elements_n3([1,1,1,3,3,2,2,2]))=={1,2}"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define longest_consecutive(nums:list)->int (length of longest consecutive sequence). Print longest_consecutive([100,4,200,1,3,2]).", "tests": ["assert longest_consecutive([100,4,200,1,3,2])==4", "assert longest_consecutive([])==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define three_sum(nums:list)->list[list[int]] returning unique triplets summing to 0 (order within triplet ascending; triplet order irrelevant). Print result for [-1,0,1,2,-1,-4].", "tests": ["res=three_sum([-1,0,1,2,-1,-4]); assert sorted(res)==sorted([[-1,-1,2],[-1,0,1]])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define four_sum(nums:list,target:int)->list[list[int]] returning unique quadruplets summing to target (sorted within; order irrelevant). Print len for [1,0,-1,0,-2,2],0.", "tests": ["res=four_sum([1,0,-1,0,-2,2],0)", "expected=[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]", "assert sorted(res)==sorted(expected)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define min_subarray_len(target:int,nums:list)->int returning minimal length of a contiguous subarray with sum>=target; return 0 if none. Print min_subarray_len(7,[2,3,1,2,4,3]).", "tests": ["assert min_subarray_len(7,[2,3,1,2,4,3])==2", "assert min_subarray_len(11,[1,2,3,4,5])==3", "assert min_subarray_len(100,[1,2])==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define length_of_longest_substring(s:str)->int without repeating characters. Print length_of_longest_substring('abcabcbb').", "tests": ["assert length_of_longest_substring('abcabcbb')==3", "assert length_of_longest_substring('bbbbb')==1", "assert length_of_longest_substring('')==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define sliding_window_max(nums:list,k:int)->list[int]. Print sliding_window_max([1,3,-1,-3,5,3,6,7],3).", "tests": ["assert sliding_window_max([1,3,-1,-3,5,3,6,7],3)==[3,3,5,5,6,7]", "assert sliding_window_max([1],1)==[1]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define matrix_multiply(A:list,B:list)->list[list[int]] for valid dimensions. Print matrix_multiply([[1,2],[3,4]],[[2,0],[1,2]]).", "tests": ["assert matrix_multiply([[1,2],[3,4]],[[2,0],[1,2]])==[[4,4],[10,8]]", "assert matrix_multiply([[6]],[[7]])==[[42]]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define set_zeroes(mat:list)->list[list[int]] setting entire row/column to 0 if any cell is 0. Print set_zeroes([[1,1,1],[1,0,1],[1,1,1]]).", "tests": ["assert set_zeroes([[1,1,1],[1,0,1],[1,1,1]])==[[1,0,1],[0,0,0],[1,0,1]]", "assert set_zeroes([[0,1]])==[[0,0]]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define search_in_rotated_sorted_array(nums:list,target:int)->int (return index or -1). Print search_in_rotated_sorted_array([4,5,6,7,0,1,2],0).", "tests": ["assert search_in_rotated_sorted_array([4,5,6,7,0,1,2],0)==4", "assert search_in_rotated_sorted_array([1],0)==-1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define find_min_in_rotated(nums:list)->int returning the minimum element in a rotated sorted array (no duplicates). Print find_min_in_rotated([3,4,5,1,2]).", "tests": ["assert find_min_in_rotated([3,4,5,1,2])==1", "assert find_min_in_rotated([4,5,6,7,0,1,2])==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define next_permutation(a:list)->list[int] producing next lexicographic permutation or smallest if last. Print next_permutation([1,2,3]).", "tests": ["assert next_permutation([1,2,3])==[1,3,2]", "assert next_permutation([3,2,1])==[1,2,3]", "assert next_permutation([1,1,5])==[1,5,1]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define combination_sum(candidates:list,target:int)->list[list[int]] allowing reuse of candidates; combinations sorted within; order of combos irrelevant. Print combination_sum([2,3,6,7],7).", "tests": ["res=combination_sum([2,3,6,7],7)", "assert sorted([sorted(x) for x in res])==sorted([[7],[2,2,3]])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define subsets(nums:list)->list[list[int]] returning all subsets (order of subsets not important). Print len(subsets([1,2,3])).", "tests": ["res=subsets([1,2,3])", "assert len(res)==8 and [] in res and [1,2] in [sorted(x) for x in res]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define subset_sum(nums:list,target:int)->bool (0/1). Print subset_sum([3,34,4,12,5,2],9).", "tests": ["assert subset_sum([3,34,4,12,5,2],9)", "assert not subset_sum([1,2,5],4)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define count_subarrays_with_sum(nums:list,k:int)->int counting subarrays summing to k (may include negatives). Print count_subarrays_with_sum([1,1,1],2).", "tests": ["assert count_subarrays_with_sum([1,1,1],2)==2", "assert count_subarrays_with_sum([1,2,3],3)==2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define find_kth_largest(nums:list,k:int)->int. Print find_kth_largest([3,2,1,5,6,4],2).", "tests": ["assert find_kth_largest([3,2,1,5,6,4],2)==5", "assert find_kth_largest([3,2,3,1,2,4,5,5,6],4)==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define kth_smallest_in_matrix(mat:list,k:int)->int where rows and columns are sorted ascending. Print kth_smallest_in_matrix([[1,5,9],[10,11,13],[12,13,15]],8).", "tests": ["m=[[1,5,9],[10,11,13],[12,13,15]]", "assert kth_smallest_in_matrix(m,8)==13", "assert kth_smallest_in_matrix(m,1)==1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define median_of_two_sorted_arrays(a:list,b:list)->float in O(log(min(n,m))). Print median_of_two_sorted_arrays([1,3],[2]).", "tests": ["assert median_of_two_sorted_arrays([1,3],[2])==2.0", "assert median_of_two_sorted_arrays([1,2],[3,4])==2.5"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Implement class RangeSumQuery with init(nums:list) and sum_range(i:int,j:int)->int (0-indexed, inclusive). Print nothing.", "tests": ["rs=RangeSumQuery([-2,0,3,-5,2,-1])", "assert rs.sum_range(0,2)==1", "assert rs.sum_range(2,5)==-1", "assert rs.sum_range(0,5)==-3"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Implement class NumMatrix with init(matrix:list) and sum_region(r1:int,c1:int,r2:int,c2:int)->int inclusive. Print nothing.", "tests": ["mat=[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]", "nm=NumMatrix(mat)", "assert nm.sum_region(2,1,4,3)==8", "assert nm.sum_region(1,1,2,2)==11", "assert nm.sum_region(1,2,2,4)==12"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Implement class MinStack supporting push(x), pop(), top()->int, get_min()->int in O(1). Print nothing.", "tests": ["s=MinStack(); s.push(-2); s.push(0); s.push(-3); assert s.get_min()==-3; s.pop(); assert s.top()==0; assert s.get_min()==-2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define basic_calculator_ii(s:str)->int evaluating '+','-','','/' (integer trunc toward zero), no parentheses. Print basic_calculator_ii('3+22').", "tests": ["assert basic_calculator_ii('3+2*2')==7", "assert basic_calculator_ii(' 3/2 ')==1", "assert basic_calculator_ii(' 3+5 / 2 ')==5"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define can_partition(nums:list)->bool checking if array can be partitioned into two subsets with equal sum. Print can_partition([1,5,11,5]).", "tests": ["assert can_partition([1,5,11,5])", "assert not can_partition([1,2,3,5])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define rob(nums:list)->int (House Robber I). Print rob([2,7,9,3,1]).", "tests": ["assert rob([1,2,3,1])==4", "assert rob([2,7,9,3,1])==12"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define rob_circular(nums:list)->int (House Robber II, circular). Print rob_circular([2,3,2]).", "tests": ["assert rob_circular([2,3,2])==3", "assert rob_circular([1,2,3,1])==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define unique_paths(m:int,n:int)->int (grid with only right/down moves). Print unique_paths(3,7).", "tests": ["assert unique_paths(3,7)==28", "assert unique_paths(3,2)==3"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define unique_paths_with_obstacles(grid:list)->int where 1 is blocked, 0 is free. Print unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]]).", "tests": ["assert unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]])==2", "assert unique_paths_with_obstacles([[0,1],[0,0]])==1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define min_path_sum(grid:list)->int (sum of path right/down min). Print min_path_sum([[1,3,1],[1,5,1],[4,2,1]]).", "tests": ["assert min_path_sum([[1,3,1],[1,5,1],[4,2,1]])==7"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define min_cost_climbing_stairs(cost:list)->int. You can start at index 0 or 1 and reach just beyond last index. Print min_cost_climbing_stairs([10,15,20]).", "tests": ["assert min_cost_climbing_stairs([10,15,20])==15", "assert min_cost_climbing_stairs([1,100,1,1,1,100,1,1,100,1])==6"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define shortest_path_unweighted(n:int,edges:list,src:int,dst:int)->int on an undirected graph; return number of edges or -1 if unreachable. Print shortest_path_unweighted(6,[(0,1),(0,2),(1,3),(2,3),(3,4),(4,5)],0,5).", "tests": ["assert shortest_path_unweighted(6,[(0,1),(0,2),(1,3),(2,3),(3,4),(4,5)],0,5)==4", "assert shortest_path_unweighted(3,[(0,1)],0,2)==-1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define num_islands(grid:list)->int counting '1' islands (4-direction). Print num_islands([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]).", "tests": ["g=[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "assert num_islands(g)==3"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define topological_sort(n:int,edges:list)->list[int] for a DAG. Any valid topological order is acceptable. Print nothing.", "tests": ["order=topological_sort(4,[(0,1),(0,2),(1,3),(2,3)])", "pos={v:i for i,v in enumerate(order)}", "for u,v in [(0,1),(0,2),(1,3),(2,3)]: assert pos[u]<pos[v]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define has_cycle_directed(n:int,edges:list)->bool for a directed graph. Print has_cycle_directed(3,[(0,1),(1,2),(2,0)]).", "tests": ["assert has_cycle_directed(3,[(0,1),(1,2),(2,0)])", "assert not has_cycle_directed(3,[(0,1),(1,2)])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define can_finish(num_courses:int,prereq:list)->bool (Course Schedule). Each pair (a,b) means b->a. Print can_finish(2,[(1,0)]).", "tests": ["assert can_finish(2,[(1,0)])", "assert not can_finish(2,[(1,0),(0,1)])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define count_connected_components(n:int,edges:list)->int on undirected graph. Print count_connected_components(5,[(0,1),(1,2),(3,4)]).", "tests": ["assert count_connected_components(5,[(0,1),(1,2),(3,4)])==2", "assert count_connected_components(3,[])==3"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define kruskal_mst_weight(n:int,edges:list)->int for undirected weighted graph. Print weight for n=4, edges=[(0,1,1),(0,2,4),(1,2,2),(1,3,5),(2,3,1)].", "tests": ["edges=[(0,1,1),(0,2,4),(1,2,2),(1,3,5),(2,3,1)]", "assert kruskal_mst_weight(4,edges)==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define prim_mst_weight(n:int,edges:list)->int for undirected weighted graph. Print prim_mst_weight for same graph as previous example.", "tests": ["edges=[(0,1,1),(0,2,4),(1,2,2),(1,3,5),(2,3,1)]", "assert prim_mst_weight(4,edges)==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define bellman_ford(n:int,edges:list,src:int)->tuple[list[int],bool] returning (distances, has_negative_cycle). Use INF=1015 for unreachable. Print nothing.", "tests": ["INF=1015", "edges=[(0,1,-1),(0,2,4),(1,2,3),(1,3,2),(1,4,2),(3,2,5),(3,1,1),(4,3,-3)]", "dist,neg=belleman:=bellman_ford(5,edges,0)", "assert not neg and dist==[0,-1,2,-2,1]", "edges2=[(0,1,1),(1,2,-1),(2,0,-1)]", "_,neg2=bellman_ford(3,edges2,0)", "assert neg2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define floyd_warshall(n:int,edges:list)->list[list[int]] returning all-pairs shortest paths (use large INF). Print shortest path 0->3 for small graph.", "tests": ["INF=1012", "dist=floyd_warshall(4,[(0,1,3),(0,2,10),(1,2,1),(2,3,2),(1,3,7)])", "assert dist[0][3]==6 and dist[0][2]==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define nearest_zero_distances(mat:list)->list[list[int]] for a 0/1 matrix returning Manhattan distance to nearest 0 for each cell. Print nothing.", "tests": ["inp=[[0,0,0],[0,1,0],[1,1,1]]", "out=[[0,0,0],[0,1,0],[1,2,1]]", "assert nearest_zero_distances(inp)==out"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define zero_one_bfs(n:int,edges:list,src:int)->list[int] for directed graph with edge weights 0 or 1. Use INF=1015. Print nothing.", "tests": ["INF=1015", "edges=[(0,1,0),(1,2,1),(0,2,1),(2,3,0),(3,4,1)]", "dist=zero_one_bfs(5,edges,0)", "assert dist[4]==2 and dist[0]==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define word_ladder_length(begin:str,end:str,word_list:list)->int returning length of shortest transformation sequence, or 0 if impossible. Print word_ladder_length('hit','cog',[...]).", "tests": ["wl=['hot','dot','dog','lot','log','cog']", "assert word_ladder_length('hit','cog',wl)==5", "assert word_ladder_length('hit','cog',['hot','dot','dog','lot','log'])==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define find_bridges(n:int,edges:list)->list[tuple[int,int]] returning all bridges in an undirected graph (sorted pairs, order of list irrelevant). Print nothing.", "tests": ["res=find_bridges(5,[(1,0),(0,2),(2,1),(0,3),(3,4)])", "exp=[(0,3),(3,4)]", "assert sorted(map(tuple,sorted([tuple(sorted(e)) for e in res])))==sorted(map(tuple,sorted([tuple(sorted(e)) for e in exp])))"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define articulation_points(n:int,edges:list)->set[int] for undirected graph. Print nothing.", "tests": ["res=articulation_points(5,[(1,0),(0,2),(2,1),(0,3),(3,4)])", "assert res=={0,3}"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define scc_kosaraju(n:int,edges:list)->list[list[int]] returning strongly connected components (each as list; order not important). Print nothing.", "tests": ["res=scc_kosaraju(5,[(1,0),(0,2),(2,1),(0,3),(3,4)])", "comp=[sorted(c) for c in res]", "assert sorted(comp)==sorted([[0,1,2],[3],[4]])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_bipartite(graph:list)->bool for adjacency lists. Print is_bipartite([[1,3],[0,2],[1,3],[0,2]]).", "tests": ["assert is_bipartite([[1,3],[0,2],[1,3],[0,2]])", "assert not is_bipartite([[1,2,3],[0,2],[0,1,3],[0,2]])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define n_queens_count(n:int)->int returning the number of distinct solutions to the n-Queens problem. Print n_queens_count(4).", "tests": ["assert n_queens_count(1)==1", "assert n_queens_count(4)==2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define solve_sudoku(board:list)->None solving Sudoku in-place ('.' empty). Use backtracking. Print nothing.", "tests": ["board=[['5','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],['.','9','8','.','.','.','.','6','.'],['8','.','.','.','6','.','.','.','3'],['4','.','.','8','.','3','.','.','1'],['7','.','.','.','2','.','.','.','6'],['.','6','.','.','.','.','2','8','.'],['.','.','.','4','1','9','.','.','5'],['.','.','.','.','8','.','.','7','9']]", "solve_sudoku(board)", "sol=[['5','3','4','6','7','8','9','1','2'],['6','7','2','1','9','5','3','4','8'],['1','9','8','3','4','2','5','6','7'],['8','5','9','7','6','1','4','2','3'],['4','2','6','8','5','3','7','9','1'],['7','1','3','9','2','4','8','5','6'],['9','6','1','5','3','7','2','8','4'],['2','8','7','4','1','9','6','3','5'],['3','4','5','2','8','6','1','7','9']]", "assert board==sol"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define word_search(board:list,word:str)->bool (adjacent 4-dir, no reuse). Print word_search on standard example.", "tests": ["b=[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]", "assert word_search(b,'ABCCED')", "assert word_search(b,'SEE')", "assert not word_search(b,'ABCB')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define min_cut_palindrome(s:str)->int (min cuts to partition into palindromes). Print min_cut_palindrome('aab').", "tests": ["assert min_cut_palindrome('aab')==1", "assert min_cut_palindrome('a')==0", "assert min_cut_palindrome('ab')==1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define subsets_with_dup(nums:list)->list[list[int]] returning all unique subsets for possibly duplicated nums. Print nothing.", "tests": ["res=subsets_with_dup([1,2,2])", "sr=sorted([tuple(sorted(x)) for x in res])", "expected=sorted([(),(1,),(2,),(1,2),(2,2),(1,2,2)])", "assert sr==expected"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define combination_sum2(candidates:list,target:int)->list[list[int]] using each candidate at most once (handle duplicates). Print nothing.", "tests": ["res=combination_sum2([10,1,2,7,6,1,5],8)", "ex=[[1,1,6],[1,2,5],[1,7],[2,6]]", "assert sorted([sorted(x) for x in res])==sorted(ex)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define restore_ip_addresses(s:str)->list[str] generating all valid IPv4 addresses. Print count for '25525511135'.", "tests": ["res=restore_ip_addresses('25525511135')", "assert set(res)=={'255.255.11.135','255.255.111.35'}"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define letter_combinations(digits:str)->list[str] (phone keypad, 2-9). Print len(letter_combinations('23')).", "tests": ["res=letter_combinations('23')", "assert set(res)=={'ad','ae','af','bd','be','bf','cd','ce','cf'}"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define is_match_regex(s:str,p:str)->bool supporting '.' and '' (classic DP). Print is_match_regex('aab','cab').", "tests": ["assert not is_match_regex('aa','a')", "assert is_match_regex('aa','a')", "assert is_match_regex('ab','.')", "assert is_match_regex('aab','cab')", "assert not is_match_regex('mississippi','misisp.')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define diff_ways_to_compute(expr:str)->list[int] computing all results by adding parentheses (operators +-). Print sorted results for '2-1-1'.", "tests": ["assert sorted(diff_ways_to_compute('2-1-1'))==[0,2]", "assert sorted(diff_ways_to_compute('23-45'))==[-34,-14,-10,-10,10]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define count_palindromic_substrings(s:str)->int (center expansion). Print count_palindromic_substrings('aaa').", "tests": ["assert count_palindromic_substrings('aaa')==6", "assert count_palindromic_substrings('abc')==3"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define min_del_to_make_equal(a:str,b:str)->int (minimum deletions to make a and b equal). Print min_del_to_make_equal('sea','eat').", "tests": ["assert min_del_to_make_equal('sea','eat')==2", "assert min_del_to_make_equal('leetcode','etco')==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define coin_change_ways(coins:list,amount:int)->int counting combinations to make amount (order-insensitive). Print coin_change_ways([1,2,5],5).", "tests": ["assert coin_change_ways([1,2,5],5)==4", "assert coin_change_ways([2],3)==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define rod_cutting(prices:list,n:int)->int maximizing value for rod length n (prices[i] is price for length i+1). Print rod_cutting([1,5,8,9],4).", "tests": ["assert rod_cutting([1,5,8,9],4)==10", "assert rod_cutting([3,5,8,9,10,17,17,20],8)==24"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define multiply_strings(num1:str,num2:str)->str multiplying big integers without converting to int. Print multiply_strings('123','456').", "tests": ["assert multiply_strings('123','456')=='56088'", "assert multiply_strings('0','0')=='0'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define phi_sieve(n:int)->list[int] returning phi[0..n]. Print phi_sieve(10)[10].", "tests": ["phi=phi_sieve(10)", "assert phi[10]==4 and sum(phi[1:6])==10"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define segmented_sieve(L:int,R:int)->list[int] returning all primes in [L,R] inclusive (R<=10**6). Print segmented_sieve(10,30).", "tests": ["assert segmented_sieve(10,30)==[11,13,17,19,23,29]", "assert segmented_sieve(1,2)==[2]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define solve_linear_system(A:list,b:list)->list[float] solving Ax=b with Gaussian elimination (assume unique solution). Print solve_linear_system([[1,1],[2,3]],[4,9]).", "tests": ["x=solve_linear_system([[1,1],[2,3]],[4,9])", "assert abs(x[0]-3)<1e-9 and abs(x[1]-1)<1e-9"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define determinant(mat:list)->float for a square matrix using Gaussian elimination with sign tracking. Print determinant([[1,2],[3,4]]).", "tests": ["assert abs(determinant([[1,2],[3,4]])+2)<1e-9", "assert abs(determinant([[6]])-6)<1e-9", "assert abs(determinant([[2,0,1],[3,0,0],[5,1,1]])-3)<1e-9"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define polygon_area(poly:list)->float (shoelace formula). Print polygon_area for rectangle (0,0),(4,0),(4,3),(0,3).", "tests": ["assert abs(polygon_area([(0,0),(4,0),(4,3),(0,3)])-12.0)<1e-9", "assert abs(polygon_area([(0,0),(1,0),(0,1)])-0.5)<1e-9"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define convex_hull(points:list)->list[tuple[int,int]] returning CCW hull without repeating the first point (Monotonic Chain). Print hull corners for a square with interior points.", "tests": ["pts=[(0,0),(2,0),(2,2),(0,2),(1,1),(1,0),(0,1)]", "h=convex_hull(pts)", "assert set(h)=={(0,0),(2,0),(2,2),(0,2)}"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define segments_intersect(p1:tuple,p2:tuple,q1:tuple,q2:tuple)->bool (inclusive of endpoints and colinear overlaps). Print for crossing segments.", "tests": ["assert segments_intersect((0,0),(4,4),(0,4),(4,0))", "assert not segments_intersect((0,0),(1,1),(1,0),(2,1))"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define point_in_polygon(poly:list,p:tuple)->bool using ray casting (return True for boundary points). Print for a square.", "tests": ["poly=[(0,0),(4,0),(4,4),(0,4)]", "assert point_in_polygon(poly,(2,2))", "assert point_in_polygon(poly,(4,4))", "assert not point_in_polygon(poly,(5,5))"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define k_closest_points(points:list,k:int)->list[tuple[int,int]] returning any k points closest to origin (Euclidean). Print k_closest_points([(1,3),(-2,2)],1).", "tests": ["res=k_closest_points([(1,3),(-2,2)],1)", "assert res==[(-2,2)]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Implement Trie with methods insert(word:str), search(word:str)->bool, starts_with(prefix:str)->bool. Print nothing.", "tests": ["t=Trie(); t.insert('apple'); assert t.search('apple'); assert not t.search('app'); assert t.starts_with('app'); t.insert('app'); assert t.search('app')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Implement FenwickTree (Binary Indexed Tree) for point updates and prefix sums. API: FenwickTree(n:int), add(i:int,delta:int), sum(i:int)->int (0-indexed, inclusive), range_sum(l:int,r:int)->int. Print nothing.", "tests": ["arr=[1,2,3,4,5]", "ft=FenwickTree(len(arr))", "for i,v in enumerate(arr): ft.add(i,v)", "assert ft.sum(0)==1 and ft.sum(4)==15 and ft.range_sum(1,3)==9", "ft.add(2,1)", "assert ft.sum(4)==16 and ft.range_sum(2,2)==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Implement SegmentTree supporting range sum query and point update. API: SegmentTree(nums:list), query(l:int,r:int)->int inclusive, update(i:int,val:int)->None. Print nothing.", "tests": ["st=SegmentTree([1,3,5])", "assert st.query(0,2)==9", "st.update(1,2)", "assert st.query(0,2)==8"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define suffix_array(s:str)->list[int] (naive is fine). Print suffix_array('banana').", "tests": ["assert suffix_array('banana')==[5,3,1,0,4,2]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define lcp_array(s:str,sa:list)->list[int] where lcp[0]=0 (Kasai). Print lcp_array for 'banana'.", "tests": ["s='banana'; sa=[5,3,1,0,4,2]", "assert lcp_array(s,sa)==[0,1,3,0,0,2]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define z_function(s:str)->list[int] with z[0]=0. Print z_function('aaaaa').", "tests": ["assert z_function('aaaaa')==[0,4,3,2,1]", "zz=z_function('abacaba'); assert zz[0]==0 and len(zz)==7"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define rabin_karp(text:str,pattern:str)->int returning first index or -1 (use rolling hash). Print rabin_karp('hello','ll').", "tests": ["assert rabin_karp('hello','ll')==2", "assert rabin_karp('aaaaa','bba')==-1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define find_anagram_indices(s:str,p:str)->list[int] returning all start indices of anagrams of p in s. Print find_anagram_indices('cbaebabacd','abc').", "tests": ["assert find_anagram_indices('cbaebabacd','abc')==[0,6]", "assert find_anagram_indices('abab','ab')==[0,1,2]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define check_valid_string(s:str)->bool where '' can be '(' or ')' or empty. Print check_valid_string('())').", "tests": ["assert check_valid_string('()')", "assert check_valid_string('()')", "assert check_valid_string('())')", "assert not check_valid_string(')(')"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define generate_matrix(n:int)->list[list[int]] creating an nÃn spiral of 1..n^2. Print generate_matrix(3).", "tests": ["assert generate_matrix(3)==[[1,2,3],[8,9,4],[7,6,5]]", "assert generate_matrix(1)==[[1]]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define game_of_life_step(board:list)->list[list[int]] computing one Game of Life step. Print nothing.", "tests": ["inp=[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]", "out=game_of_life_step(inp)", "assert out==[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define oranges_rotting(grid:list)->int returning minutes to rot all oranges, or -1 if impossible. Print oranges_rotting([[2,1,1],[1,1,0],[0,1,1]]).", "tests": ["assert oranges_rotting([[2,1,1],[1,1,0],[0,1,1]])==4", "assert oranges_rotting([[0,2]])==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define pacific_atlantic(heights:list)->list[list[int]] returning coordinates [r,c] flowing to both oceans (order irrelevant). Print for a small matrix.", "tests": ["cells=pacific_atlantic([[1,2],[4,3]])", "assert sorted(map(tuple,cells))==sorted([(0,1),(1,0),(1,1)])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define solve_surrounded_regions(board:list)->None to capture surrounded 'O' regions (flip to 'X'). Print nothing.", "tests": ["board=[['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']]", "solve_surrounded_regions(board)", "expected=[['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']]", "assert board==expected"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define find_order(num_courses:int,prereq:list)->list[int] (Course Schedule II). Return empty list if impossible. Print find_order(2,[(1,0)]).", "tests": ["assert find_order(2,[(1,0)]) in ([0,1],)", "assert find_order(2,[(1,0),(0,1)])==[]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define maximum_swap(num:int)->int swapping at most one pair of digits to get the maximum value. Print maximum_swap(2736).", "tests": ["assert maximum_swap(2736)==7236", "assert maximum_swap(9973)==9973"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define remove_k_digits(num:str,k:int)->str to form the smallest possible number (no leading zeros; return '0' if empty). Print remove_k_digits('1432219',3).", "tests": ["assert remove_k_digits('1432219',3)=='1219'", "assert remove_k_digits('10200',1)=='200'", "assert remove_k_digits('10',2)=='0'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define count_bits_upto(n:int)->list[int] where result[i] is popcount(i) for i in [0..n]. Print count_bits_upto(5).", "tests": ["assert count_bits_upto(5)==[0,1,1,2,1,2]", "assert count_bits_upto(0)==[0]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define single_number(nums:list)->int where every element appears twice except one. Print single_number([4,1,2,1,2]).", "tests": ["assert single_number([2,2,1])==1", "assert single_number([4,1,2,1,2])==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define single_number_thrice(nums:list)->int where every element appears three times except one. Print single_number_thrice([2,2,3,2]).", "tests": ["assert single_number_thrice([2,2,3,2])==3", "assert single_number_thrice([0,1,0,1,0,1,99])==99"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define range_xor(L:int,R:int)->int computing XOR of all integers in [L,R]. Print range_xor(3,9).", "tests": ["assert range_xor(3,9)==2", "assert range_xor(0,0)==0", "assert range_xor(0,4)==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define word_break(s:str,word_dict:list)->bool indicating if s can be segmented into dictionary words. Print word_break('leetcode',['leet','code']).", "tests": ["assert word_break('leetcode',['leet','code'])", "assert word_break('applepenapple',['apple','pen'])", "assert not word_break('catsandog',['cats','dog','sand','and','cat'])"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define longest_increasing_path(matrix:list)->int (move 4-dir to strictly greater). Print longest_increasing_path([[9,9,4],[6,6,8],[2,1,1]]).", "tests": ["assert longest_increasing_path([[9,9,4],[6,6,8],[2,1,1]])==4", "assert longest_increasing_path([[3,4,5],[3,2,6],[2,2,1]])==4"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define find_peak_element(nums:list)->int returning any index of a peak (neighbors strictly smaller where applicable). Print find_peak_element([1,2,3,1]).", "tests": ["i=find_peak_element([1,2,3,1]); assert i in (2,)", "j=find_peak_element([1,2,1,3,5,6,4]); assert [1,2,1,3,5,6,4][j] in (2,6)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define kth_smallest(nums:list,k:int)->int using Quickselect (1-indexed k). Print kth_smallest([3,2,1,5,6,4],2).", "tests": ["assert kth_smallest([3,2,1,5,6,4],2)==2", "assert kth_smallest([7,10,4,3,20,15],3)==7"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define paint_house(costs:list)->int minimal total cost to paint houses in 3 colors with no adjacent same color. Print paint_house([[17,2,17],[16,16,5],[14,3,19]]).", "tests": ["assert paint_house([[17,2,17],[16,16,5],[14,3,19]])==10", "assert paint_house([[7,6,2]])==2"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define maximal_square(matrix:list)->int returning the area of the largest square of '1's. Print maximal_square on small examples.", "tests": ["matrix=[['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]", "assert maximal_square(matrix)==4", "assert maximal_square([['0']])==0", "assert maximal_square([['1']])==1"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define num_decodings(s:str)->int counting ways to decode '1'..'26'. Print num_decodings('226').", "tests": ["assert num_decodings('12')==2", "assert num_decodings('226')==3", "assert num_decodings('06')==0"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define num_trees(n:int)->int returning the number of unique BSTs storing values 1..n (Catalan). Print num_trees(3).", "tests": ["assert num_trees(0)==1", "assert num_trees(1)==1", "assert num_trees(3)==5"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define add_binary(a:str,b:str)->str adding two binary strings. Print add_binary('1010','1011').", "tests": ["assert add_binary('11','1')=='100'", "assert add_binary('1010','1011')=='10101'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define search_matrix(matrix:list,target:int)->bool where each row is sorted and first of each row > last of previous. Print search_matrix on sample.", "tests": ["m=[[1,3,5,7],[10,11,16,20],[23,30,34,60]]", "assert search_matrix(m,3)", "assert not search_matrix(m,13)"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define nth_ugly_number(n:int)->int (ugly numbers with factors 2,3,5). Print nth_ugly_number(10).", "tests": ["assert nth_ugly_number(1)==1", "assert nth_ugly_number(10)==12"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define merge_k_sorted_lists(lists:list)->list[int] merging all into one sorted list. Print merge_k_sorted_lists([[1,4,5],[1,3,4],[2,6]]).", "tests": ["assert merge_k_sorted_lists([[1,4,5],[1,3,4],[2,6]])==[1,1,2,3,4,4,5,6]", "assert merge_k_sorted_lists([[],[1],[0,2]])==[0,1,2]"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define day_of_week(y:int,m:int,d:int)->str returning weekday name using e.g. Zeller's congruence (Gregorian). Print day_of_week(2020,1,1).", "tests": ["assert day_of_week(2020,1,1)=='Wednesday'", "assert day_of_week(1970,1,1)=='Thursday'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define add_time(hhmm:str, minutes:int)->str adding minutes to 'HH:MM' 24-hour time, wrap around midnight. Print add_time('23:45',80).", "tests": ["assert add_time('23:45',80)=='01:05'", "assert add_time('00:00',0)=='00:00'"], "timeout_s": 2, "memory_mb": 256}
{"prompt": "Define largest_rectangle_area(heights:list)->int (histogram). Print largest_rectangle_area([2,1,5,6,2,3]).", "tests": ["assert largest_rectangle_area([2,1,5,6,2,3])==10", "assert largest_rectangle_area([2,4])==4"], "timeout_s": 2, "memory_mb": 256}
