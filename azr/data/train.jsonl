{"prompt":"Define a function fib(n:int)->int computing the nth Fibonacci number (n>=0). Then print fib(10).","tests":["assert fib(0)==0; assert fib(1)==1; assert fib(10)==55"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define factorial(n:int)->int using iteration (no recursion). Print factorial(8).","tests":["assert factorial(0)==1; assert factorial(5)==120; assert factorial(8)==40320"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define gcd(a:int,b:int)->int and lcm(a:int,b:int)->int. Use Euclid for gcd. Print lcm(21,6).","tests":["assert gcd(54,24)==6; assert lcm(21,6)==42; assert lcm(5,7)==35"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define is_prime(n:int)->bool (n>=0). Reasonably efficient for n<=10^6. Print is_prime(101).","tests":["assert is_prime(2) and is_prime(3) and is_prime(101); assert not is_prime(0) and not is_prime(1) and not is_prime(100)"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define sieve(n:int)->list[int] returning all primes <= n. Print len(sieve(1000)).","tests":["p=sieve(30); assert p==[2,3,5,7,11,13,17,19,23,29]; assert len(sieve(2))==1; assert len(sieve(100))==25"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define nth_prime(k:int)->int (1-indexed). Print nth_prime(25).","tests":["assert nth_prime(1)==2; assert nth_prime(6)==13; assert nth_prime(25)==97"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define mod_pow(a:int,b:int,m:int)->int computing a^b mod m by fast exponentiation. Print mod_pow(5,117,19).","tests":["assert mod_pow(2,10,1000)==24; assert mod_pow(5,117,19)==1"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define int_to_roman(num:int)->str (1..3999). Print int_to_roman(944).","tests":["assert int_to_roman(3)=='III'; assert int_to_roman(58)=='LVIII'; assert int_to_roman(944)=='CMXLIV'"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define roman_to_int(s:str)->int (valid Roman). Print roman_to_int('MCMXCIV').","tests":["assert roman_to_int('III')==3; assert roman_to_int('LVIII')==58; assert roman_to_int('MCMXCIV')==1994"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define is_palindrome_num(x:int)->bool without converting to string (use math). Print is_palindrome_num(12321).","tests":["assert is_palindrome_num(0); assert is_palindrome_num(12321); assert not is_palindrome_num(123)"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define is_armstrong(n:int)->bool (base 10). Print is_armstrong(371).","tests":["assert is_armstrong(0); assert is_armstrong(1); assert is_armstrong(153); assert is_armstrong(371); assert not is_armstrong(100)"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define reverse_str(s:str)->str without slicing. Print reverse_str('stressed').","tests":["assert reverse_str('stressed')=='desserts'; assert reverse_str('ab')=='ba'; assert reverse_str('')==''"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define is_anagram(a:str,b:str)->bool (ignore case and spaces). Print is_anagram('Listen','Silent').","tests":["assert is_anagram('Listen','Silent'); assert is_anagram('A gentleman','Elegant man'); assert not is_anagram('abc','ab')"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define is_isogram(s:str)->bool (letters only, ignore case/hyphens/spaces). Print is_isogram('background').","tests":["assert is_isogram('background'); assert not is_isogram('letter'); assert is_isogram('six-year-old')"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define count_vowels(s:str)->int counting a,e,i,o,u (both cases). Print count_vowels('Apples and Oranges').","tests":["assert count_vowels('')==0; assert count_vowels('Apples and Oranges')==7"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define rle_encode(s:str)->str (run-length encoding, e.g., 'AAAB'->'3A1B'). Print rle_encode('WWWWBWW').","tests":["assert rle_encode('AAAB')=='3A1B'; assert rle_encode('WWWWBWW')=='4W1B2W'; assert rle_encode('')==''"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define caesar_cipher(s:str,shift:int)->str shifting letters (a-z, A-Z) with wrap; preserve non-letters. Print caesar_cipher('Abc-Z!',3).","tests":["assert caesar_cipher('Abc-Z!',3)=='Def-C!'; assert caesar_cipher('xyz',4)=='bcd'"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define most_common_char(s:str)->str returning the most frequent non-space char; ties -> smallest lexicographically. Print most_common_char('abbcccdddde').","tests":["assert most_common_char('abbcccdddde')=='d'; assert most_common_char('aabb')=='a'"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define two_sum(nums:list[int],target:int)->tuple[int,int] returning indices i<j with nums[i]+nums[j]==target. Print two_sum([2,7,11,15],9).","tests":["assert two_sum([2,7,11,15],9) in [(0,1)]; assert set(two_sum([3,2,4],6))=={1,2}"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define unique(seq:list)->list preserving first occurrence order. Print unique([1,2,2,3,1,4]).","tests":["assert unique([1,2,2,3,1,4])==[1,2,3,4]; assert unique([])==[]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define rotate_right(a:list[int],k:int)->list[int] rotating right by k (k may exceed len). Print rotate_right([1,2,3,4,5],2).","tests":["assert rotate_right([1,2,3,4,5],2)==[4,5,1,2,3]; assert rotate_right([1],10)==[1]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define flatten(nested:list)->list that flattens a list of lists by one level only. Print flatten([[1,2],[3],[4,5]]).","tests":["assert flatten([[1,2],[3],[4,5]])==[1,2,3,4,5]; assert flatten([])==[]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define group_anagrams(words:list[str])->list[list[str]]. Order within groups doesn't matter; groups order doesn't matter. Print groups for ['eat','tea','tan','ate','nat','bat'].","tests":["res=group_anagrams(['eat','tea','tan','ate','nat','bat']); assert sorted([sorted(g) for g in res])==sorted([['ate','eat','tea'],['nat','tan'],['bat']])"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define top_k_frequent(nums:list[int],k:int)->list[int]. If tie, smaller number first. Print top_k_frequent([1,1,1,2,2,3],2).","tests":["assert top_k_frequent([1,1,1,2,2,3],2)==[1,2]; assert top_k_frequent([4,4,4,5,5,6],2)==[4,5]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define merge_intervals(iv:list[list[int]])->list[list[int]] merging overlaps; output sorted by start. Print merge_intervals([[1,3],[2,6],[8,10],[15,18]]).","tests":["assert merge_intervals([[1,3],[2,6],[8,10],[15,18]])==[[1,6],[8,10],[15,18]]; assert merge_intervals([[1,4],[4,5]])==[[1,5]]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define binary_search(a:list[int],x:int)->int returning index or -1 if absent (a is sorted asc). Print binary_search([1,3,5,7,9],7).","tests":["assert binary_search([1,3,5,7,9],7)==3; assert binary_search([1,3,5],2)==-1"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define merge_sort(a:list[int])->list[int] (no built-in sort). Print merge_sort([3,1,4,1,5,9]).","tests":["assert merge_sort([3,1,4,1,5,9])==[1,1,3,4,5,9]; assert merge_sort([])==[]; assert merge_sort([1])==[1]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define coin_change(coins:list[int],amount:int)->int returning min coins to make amount or -1 if impossible. Print coin_change([1,2,5],11).","tests":["assert coin_change([1,2,5],11)==3; assert coin_change([2],3)==-1"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define lis_length(nums:list[int])->int returning length of the Longest Increasing Subsequence. Print lis_length([10,9,2,5,3,7,101,18]).","tests":["assert lis_length([10,9,2,5,3,7,101,18])==4; assert lis_length([0,1,0,3,2,3])==4"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define edit_distance(a:str,b:str)->int (Levenshtein, insert/delete/replace cost 1). Print edit_distance('intention','execution').","tests":["assert edit_distance('kitten','sitting')==3; assert edit_distance('intention','execution')==5"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define knapsack_01(W:int,wt:list[int],val:list[int])->int maximizing value with capacity W. Print knapsack_01(7,[6,3,4,2],[30,14,16,9]).","tests":["assert knapsack_01(7,[6,3,4,2],[30,14,16,9])==46; assert knapsack_01(10,[3,3,3],[10,20,30])==60"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define transpose(mat:list[list[int]])->list[list[int]]. Print transpose([[1,2,3],[4,5,6]]).","tests":["assert transpose([[1,2,3],[4,5,6]])==[[1,4],[2,5],[3,6]]; assert transpose([[1]])==[[1]]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define rotate_matrix(mat:list[list[int]])->list[list[int]] rotating square matrix 90Â° clockwise in-place or return new. Print rotate_matrix([[1,2],[3,4]]).","tests":["assert rotate_matrix([[1,2],[3,4]])==[[3,1],[4,2]]; assert rotate_matrix([[1]])==[[1]]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define spiral_order(mat:list[list[int]])->list[int] returning elements in spiral order. Print spiral_order([[1,2,3],[4,5,6],[7,8,9]]).","tests":["assert spiral_order([[1,2,3],[4,5,6],[7,8,9]])==[1,2,3,6,9,8,7,4,5]"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define dijkstra(n:int,edges:list[tuple[int,int,int]],src:int)->list[int] returning min distances (INF=10**15) on non-negative weighted graph. Print dijkstra(5,[(0,1,2),(0,2,5),(1,2,1),(1,3,2),(2,3,3),(3,4,1)],0).","tests":["INF=10**15; dist=dijkstra(5,[(0,1,2),(0,2,5),(1,2,1),(1,3,2),(2,3,3),(3,4,1)],0); assert dist[0]==0 and dist[1]==2 and dist[2]==3 and dist[3]==4 and dist[4]==5"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define eval_rpn(tokens:list[str])->int evaluating Reverse Polish Notation with +,-,*,/. Integer division truncates toward zero. Print eval_rpn(['2','1','+','3','*']).","tests":["assert eval_rpn(['2','1','+','3','*'])==9; assert eval_rpn(['4','13','5','/','+'])==6; assert eval_rpn(['10','6','9','3','+','-11','*','/','*','17','+','5','+'])==22"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define parse_csv_line(line:str)->list[str] handling commas and double-quotes per RFC basics (quote escape by doubling). Print parse_csv_line('\"a,b\",c,\"d\"\"e\"').","tests":["assert parse_csv_line('\"a,b\",c,\"d\"\"e\"')==['a,b','c','d\"e']; assert parse_csv_line('a,,b')==['a','','b']"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define is_valid_parentheses(s:str)->bool for (),{},[]. Print is_valid_parentheses('([{}])').","tests":["assert is_valid_parentheses('()') and is_valid_parentheses('([{}])'); assert not is_valid_parentheses('(]')"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define generate_parentheses(n:int)->list[str] generating all valid combinations of n pairs of '()'. Print len(generate_parentheses(3)).","tests":["g=generate_parentheses(3); assert set(g)==set(['((()))','(()())','(())()','()(())','()()()'])"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define permutations(lst:list[int])->list[list[int]] returning all permutations (order of permutations not important). Print len(permutations([1,2,3])).","tests":["res=permutations([1,2,3]); assert len(res)==6 and sorted([tuple(x) for x in res])==sorted([(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)])"],"timeout_s":2,"memory_mb":256}
{"prompt":"Implement class LRUCache(capacity:int) with methods get(key:int)->int and put(key:int,value:int)->None. get returns -1 if missing. Use O(1) operations. Print nothing, just define the class.","tests":["c=LRUCache(2); c.put(1,1); c.put(2,2); assert c.get(1)==1; c.put(3,3); assert c.get(2)==-1; c.put(4,4); assert c.get(1)==-1; assert c.get(3)==3 and c.get(4)==4"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define stack_with_queues supporting push(x), pop()->int, top()->int, empty()->bool using two queues (collections.deque allowed). Print nothing.","tests":["from collections import deque; s=stack_with_queues(); s.push(1); s.push(2); assert s.top()==2; assert s.pop()==2; assert not s.empty(); assert s.pop()==1; assert s.empty()"],"timeout_s":2,"memory_mb":256}
{"prompt":"Define queue_with_stacks supporting push(x), pop()->int, peek()->int, empty()->bool using two stacks (lists). Print nothing.","tests":["q=queue_with_stacks(); q.push(1); q.push(2); assert q.peek()==1; assert q.pop()==1; assert not q.empty(); assert q.pop()==2; assert q.empty()"],"timeout_s":2,"memory_mb":256}
